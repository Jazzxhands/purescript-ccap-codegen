module Ccap.Codegen.Scala
  ( outputSpec
  ) where

import Prelude
import Ccap.Codegen.Annotations as Annotations
import Ccap.Codegen.Env (Env, askModule, lookupTypeDecl)
import Ccap.Codegen.Parser.Export as Export
import Ccap.Codegen.Shared (DelimitedLiteralDir(..), OutputSpec, delimitedLiteral, indented, modulesInScope)
import Ccap.Codegen.Types (Annotations, Exports, Module, ModuleName, Primitive(..), RecordProp, TRef, TopType(..), Type(..), TypeDecl(..), ValidatedModule, isRecord, typeDeclName, typeDeclTopType)
import Ccap.Codegen.Util (fromMaybeT, maybeT)
import Control.Alt (alt)
import Control.Monad.Maybe.Trans (MaybeT(..), runMaybeT)
import Control.Monad.Reader (Reader, ask, asks, runReader)
import Data.Array (foldl, (:))
import Data.Array as Array
import Data.Compactable (compact)
import Data.Foldable (intercalate)
import Data.Maybe (Maybe(..), fromMaybe, maybe)
import Data.Monoid (guard)
import Data.String as String
import Data.Traversable (traverse)
import Node.Path (FilePath)
import Text.PrettyPrint.Boxes (Box, char, emptyBox, hcat, nullBox, render, text, vcat, vsep, (//), (<<+>>), (<<>>))
import Text.PrettyPrint.Boxes (left, top) as Boxes

type Codegen
  = Reader Env

runCodegen :: forall a. Env -> Codegen a -> a
runCodegen = flip runReader

outputSpec :: OutputSpec
outputSpec =
  { render: render <<< oneModule
  , filePath: modulePath
  }

modulePath :: ValidatedModule -> FilePath
modulePath mod = (Export.toPath mod.exports.scalaPkg) <> ".scala"

oneModule :: ValidatedModule -> Box
oneModule mod = do
  let
    modDecl = primaryClass mod

    env =
      { defaultPrefix: Nothing
      , currentModule:
          mod
            { imports = mod.imports <#> _.exports.scalaPkg
            }
      , allModules: modulesInScope mod
      }

    body =
      runCodegen env do
        modDeclOutput <- traverse (typeDecl TopLevelCaseClass) modDecl
        declsOutput <- traverse (typeDecl CompanionObject) mod.types
        pure
          $ Array.fromFoldable modDeclOutput
          <> [ text ("object " <> (objectName mod) <> " {") ]
          <> (declsOutput <#> indented)
          <> [ char '}' ]
  vsep 1 Boxes.left do
    [ text "// This file is automatically generated. Do not edit."
    , text ("package " <> classPackage mod)
    , imports mod
    ]
      <> body

objectName :: forall r. { exports :: Exports | r } -> String
objectName { exports: { scalaPkg } } = fromMaybe scalaPkg $ Array.last $ Export.split scalaPkg

classPackage :: forall r. { exports :: Exports | r } -> String
classPackage { exports: { scalaPkg } } = maybe scalaPkg Export.join $ Array.init $ Export.split scalaPkg

curly :: Box -> Array Box -> Box
curly pref inner = vcat Boxes.left (pref <<+>> char '{' : (indented <$> inner) `Array.snoc` char '}')

paren :: Box -> Array Box -> Box
paren pref inner = vcat Boxes.left (pref <<>> char '(' : (indented <$> inner) `Array.snoc` char ')')

paren_ :: Box -> Array Box -> Box -> Box
paren_ pref inner suffix = vcat Boxes.left (pref <<>> char '(' : (indented <$> inner) `Array.snoc` (char ')' <<>> suffix))

-- TODO: Clean up when we switch to a proper pretty printer.
-- Like `paren`, but outputs on a sigle line.
paren1 :: Box -> Array Box -> Box
paren1 pref inner = hcat Boxes.top (pref <<>> char '(' : inner `Array.snoc` char ')')

standardImports :: Array String
standardImports =
  [ "gov.wicourts.jsoncommon.Encoder"
  , "gov.wicourts.jsoncommon.Decoder"
  , "scalaz.Monad"
  ]

imports :: ValidatedModule -> Box
imports mod =
  let
    pkg = classPackage mod

    samePkg impt = classPackage impt == pkg

    impts = _.exports.scalaPkg <$> Array.filter (not <<< samePkg) mod.imports

    all = impts <> standardImports # Array.sort >>> Array.nub
  in
    vcat Boxes.left (all <#> \s -> text ("import " <> s))

defEncoder :: Boolean -> String -> Box -> Box
defEncoder includeName name enc =
  let
    includedName = if includeName then name else ""
  in
    text ("lazy val jsonEncoder" <> includedName <> ": Encoder[" <> name <> ", argonaut.Json] =")
      // indented enc

defDecoder :: Boolean -> String -> String -> Box -> Box
defDecoder includeName name dType dec =
  let
    includedName = if includeName then name else ""
  in
    text ("def jsonDecoder" <> includedName <> "[M[_]: Monad]: Decoder." <> dType <> "[M, " <> name <> "] =")
      // indented dec

wrapEncoder :: String -> Type -> Box -> Codegen Box
wrapEncoder name t enc = do
  e <- encoder t
  pure $ defEncoder true name ((e <<>> text ".compose") `paren` [ enc ])

wrapDecoder :: Annotations -> String -> Type -> Box -> Codegen Box
wrapDecoder annots name t dec = do
  d <- decoderType t
  topDec <- decoder annots t
  let
    body = (topDec <<>> text ".disjunction.andThen") `paren` [ dec ] // text ".validation"
  pure $ defDecoder true name d body

data TypeDeclOutputMode
  = TopLevelCaseClass
  | CompanionObject

derive instance eqTypeDeclOutputMode :: Eq TypeDeclOutputMode

typeDecl :: TypeDeclOutputMode -> TypeDecl -> Codegen Box
typeDecl outputMode (TypeDecl name tt an) = case tt of
  Type t -> do
    dTy <- decoderType t
    ty <- typeDef outputMode t
    e <- encoder t
    d <- decoder an t
    pure
      $ text "type"
      <<+>> text name
      <<+>> char '='
      <<+>> ty
      // defEncoder true name e
      // defDecoder true name dTy d
  Wrap t -> do
    case Annotations.getWrapOpts "scala" an of
      Nothing -> do
        dTy <- decoderType t
        ty <- typeDef outputMode t
        e <- encoder t
        d <- decoder an t
        let
          tagname = text (name <> "T")

          scalatyp = text "scalaz.@@[" <<>> ty <<>> char ',' <<+>> tagname <<>> char ']'
        pure
          $ vcat Boxes.left
              [ text "final abstract class" <<+>> tagname
              , text "type" <<+>> text name <<+>> char '=' <<+>> scalatyp
              , text "val" <<+>> text name <<>> char ':' <<+>> text "scalaz.Tag.TagOf["
                  <<>> tagname
                  <<>> text "] = scalaz.Tag.of["
                  <<>> tagname
                  <<>> char ']'
              , defEncoder true name (e <<>> text ".tagged")
              , defDecoder true name dTy (d <<>> text ".tagged")
              ]
      Just { typ, decode, encode } -> do
        wrappedEncoder <- wrapEncoder name t (text encode)
        wrappedDecoder <- wrapDecoder an name t (text decode <<>> text ".disjunction")
        pure
          $ text "type"
          <<+>> text name
          <<+>> char '='
          <<+>> text typ
          // wrappedEncoder
          // wrappedDecoder
  Record props -> do
    mod <- asks _.currentModule
    recordFieldTypes <- traverse (recordFieldType outputMode) props
    recordFieldEncoders <- traverse recordFieldEncoder props
    let
      cls = (text "final case class" <<+>> text name) `paren` recordFieldTypes

      enc = defEncoder (mod.name /= name) name (text "x => argonaut.Json.obj" `paren` recordFieldEncoders)
    decBody <- case Array.length props of
      1 -> maybe (pure (emptyBox 0 0)) (singletonRecordDecoder name) (Array.head props)
      x
        | x <= 12 -> smallRecordDecoder name props
      x -> largeRecordDecoder name props
    let
      dec = defDecoder (mod.name /= name) name "Form" decBody

      fieldNamesTarget =
        if mod.name == name then
          Nothing
        else
          Just name

      names = fieldNames fieldNamesTarget (props <#> _.name)

      output
        | mod.name == name && outputMode == TopLevelCaseClass = cls

      output
        | mod.name == name && outputMode == CompanionObject = enc // dec // names

      output
        | otherwise = cls // enc // dec // names
    pure output
  Sum vs -> do
    let
      trait = (text "sealed trait" <<+>> text name) `curly` [ text "def tag: String" ]

      variants =
        vs
          <#> \v ->
              text ("case object " <> v <> " extends " <> name)
                `curly`
                  [ text ("override def tag: String = " <> show v) ]

      assocs =
        vs
          <#> \v ->
              paren1 (emptyBox 0 0) [ text (show v), text ", ", text name <<>> char '.' <<>> text v ] <<>> char ','

      params = text (show name) <<>> char ',' : assocs
    enc <- wrapEncoder name (Primitive PString) (text "_.tag")
    dec <-
      wrapDecoder
        an
        name
        (Primitive PString)
        (((text ("Decoder.enum[M, " <> name) <<>> char ']') `paren` params) // text ".disjunction")
    pure $ trait // ((text "object" <<+>> text name) `curly` variants) // enc // dec

fieldNames :: Maybe String -> Array String -> Box
fieldNames mod names = maybe body (\m -> curly (text "object" <<+>> text m) [ body ]) mod
  where
  body = curly (text "object" <<+>> text "FieldNames") (names <#> fieldNameConst)

  fieldNameConst s = text "val" <<+>> text (valName s) <<>> text ": String" <<+>> text "=" <<+>> text (show s)

  valName s =
    let
      { before, after } = String.splitAt 1 s
    in
      String.toUpper before <> after

primitive :: Primitive -> Box
primitive =
  text
    <<< case _ of
        PBoolean -> "Boolean"
        PInt -> "Int"
        PDecimal -> "BigDecimal"
        PString -> "String"
        PStringValidationHack -> "StringValidationHack"

generic :: String -> Box -> Box
generic typeName param = text typeName <<>> char '[' <<>> param <<>> char ']'

list :: Box -> Box
list = generic "List"

option :: Box -> Box
option = generic "Option"

typeDef :: TypeDeclOutputMode -> Type -> Codegen Box
typeDef mode = case _ of
  Ref _ tRef -> typeRef mode tRef
  Array t -> list <$> typeDef mode t
  Option t -> option <$> typeDef mode t
  Primitive p -> pure $ primitive p

typeRef :: TypeDeclOutputMode -> TRef -> Codegen Box
typeRef mode { mod, typ: typeName } = do
  currentModule <- asks _.currentModule
  fromMaybeT (internalTypeRef mode currentModule typeName) do
    importedModuleName <- maybeT mod
    importedModule <- MaybeT $ askModule importedModuleName
    importedType <- maybeT $ lookupTypeDecl typeName importedModule
    pure $ externalTypeRef importedModule importedType

internalTypeRef :: TypeDeclOutputMode -> Module -> String -> Box
internalTypeRef mode currentModule = case mode of
  TopLevelCaseClass -> text <<< prefix [ objectName currentModule ]
  CompanionObject -> text

externalTypeRef :: Module -> TypeDecl -> Box
externalTypeRef importedModule importedType =
  let
    scalaName = objectName importedModule

    pkg = packageAnnotation importedModule

    path = Array.snoc (Array.fromFoldable pkg) scalaName

    typeName = typeDeclName importedType
  in
    text
      if needsQualifier scalaName importedType then
        prefix path $ typeName
      else
        typeName

primaryClass :: forall r. { name :: ModuleName, types :: Array TypeDecl | r } -> Maybe TypeDecl
primaryClass { name, types } = Array.find (isPrimaryClass name) types

isPrimaryClass :: ModuleName -> TypeDecl -> Boolean
isPrimaryClass modName typeD = modName == typeDeclName typeD && (isRecord $ typeDeclTopType typeD)

needsQualifier :: ModuleName -> TypeDecl -> Boolean
needsQualifier modName = not <<< isPrimaryClass modName

packageAnnotation :: Module -> Maybe String
packageAnnotation = Annotations.field "scala" "package" <<< _.annots

prefix :: Array String -> String -> String
prefix names = intercalate "." <<< Array.snoc names

encoder :: Type -> Codegen Box
encoder = case _ of
  Ref _ tRef -> text <$> jsonTypeRef "Encoder" tRef
  Array t -> encoder t <#> jsonList
  Option t -> encoder t <#> jsonOption
  Primitive p -> pure $ text $ "Encoder" <> jsonPrimitive p

decoder :: Annotations -> Type -> Codegen Box
decoder annots = case _ of
  Ref _ tRef -> text <$> jsonTypeRef "Decoder" tRef
  Array t -> decoder annots t <#> jsonList
  Option t -> decoder annots t <#> jsonOption
  Primitive p -> pure $ (text $ "Decoder" <> jsonPrimitive p) <<>> decoderValidations annots

jsonRef :: String -> String -> String
jsonRef which typ = "json" <> which <> typ -- should be blank if it is the primary class

jsonTypeRef :: String -> TRef -> Codegen String
jsonTypeRef which { mod, typ } =
  let
    externalJson =
      runMaybeT do
        modName <- maybeT mod
        extMod <- MaybeT $ askModule modName
        extTypeDecl <- maybeT $ lookupTypeDecl typ extMod
        let
          path = Array.snoc (Array.fromFoldable $ packageAnnotation extMod) modName
        pure $ prefix path $ jsonRef which $ guard (needsQualifier modName extTypeDecl) typ

    internalJson =
      runMaybeT do
        thisMod <- MaybeT $ Just <$> asks _.currentModule
        decl <- maybeT $ lookupTypeDecl typ thisMod
        pure $ jsonRef which $ guard (needsQualifier thisMod.name decl) typ

    default = jsonRef which typ
  in
    alt <$> internalJson <*> externalJson <#> fromMaybe default

jsonList :: Box -> Box
jsonList json = json <<>> text ".list"

jsonOption :: Box -> Box
jsonOption json = json <<>> text ".option"

jsonPrimitive :: Primitive -> String
jsonPrimitive = case _ of
  PBoolean -> ".boolean"
  PInt -> ".int"
  PDecimal -> ".decimal"
  PString -> ".string"
  PStringValidationHack -> ".stringValidationHack"

decoderValidations :: Annotations -> Box
decoderValidations annots = foldl (<<>>) nullBox validations
  where
  validations =
    compact
      [ maxLengthValidation <$> Annotations.getMaxLength annots
      , minLengthValidation <$> Annotations.getMinLength annots
      , maxSizeValidation <$> Annotations.getMaxSize annots
      , positiveValidation <$> Annotations.getIsPositive annots
      ]

maxLengthValidation :: String -> Box
maxLengthValidation max = text $ ".maxLength(" <> max <> ")"

minLengthValidation :: String -> Box
minLengthValidation min = text $ ".minLength(" <> min <> ")"

maxSizeValidation :: String -> Box
maxSizeValidation max = text $ ".maxSize(" <> max <> ")"

positiveValidation :: Unit -> Box
positiveValidation _ = text $ ".positive"

decoderType :: Type -> Codegen String
decoderType ty = case ty of
  Ref _ { mod, typ } -> do
    { currentModule, allModules } <- ask
    let
      external = mod >>= (\m -> Array.find (\n -> n.name == m) allModules)

      myMod = fromMaybe currentModule external

      tt =
        Array.find (\(TypeDecl n _ _) -> n == typ) myMod.types
          <#> (\(TypeDecl _ t _) -> t)
    maybe (pure "MISSING") decoderTopType tt
  Array t -> decoderType t
  Option t -> decoderType t
  Primitive _ -> pure "Field"

decoderTopType :: TopType -> Codegen String
decoderTopType = case _ of
  Type ty -> decoderType ty
  Wrap ty -> decoderType ty
  Record _ -> pure "Form"
  Sum _ -> pure "Field"

encodeType :: Type -> Box -> Codegen Box
encodeType t e = encoder t <#> (_ <<>> text ".encode" `paren1` [ e ])

recordFieldType :: TypeDeclOutputMode -> RecordProp -> Codegen Box
recordFieldType mode { name, typ } = do
  ty <- typeDef mode typ
  pure $ text name <<>> char ':' <<+>> ty <<>> char ','

recordFieldEncoder :: RecordProp -> Codegen Box
recordFieldEncoder { name, typ } = do
  ty <- encodeType typ (text ("x." <> name))
  pure $ text (show name <> " ->") <<+>> ty <<>> char ','

recordFieldDecoder :: RecordProp -> Codegen Box
recordFieldDecoder { name, typ, annots } = decoder annots typ <#> (_ <<>> recordFieldProperty name)

recordFieldProperty :: String -> Box
recordFieldProperty name = text ".property(" <<>> text (show name) <<>> char ')'

singletonRecordDecoder :: String -> RecordProp -> Codegen Box
singletonRecordDecoder name prop = recordFieldDecoder prop <#> (_ <<>> text (".map(" <> name <> ".apply)"))

smallRecordDecoder :: String -> Array RecordProp -> Codegen Box
smallRecordDecoder name props = do
  ps <- traverse (\r -> recordFieldDecoder r <#> (_ <<>> char ',')) props
  pure
    $ paren_
        (text ("scalaz.Apply[Decoder.Form[M, *]].apply" <> show (Array.length props)))
        ps
        (text ("(" <> name <> ".apply)"))

-- | tree type for bulding scalaz Apply statements
data TupleApplyStatement
  = Final (Array RecordProp)
  | Intermediate (Array TupleApplyStatement)

largeRecordDecoder :: String -> Array RecordProp -> Codegen Box
largeRecordDecoder name props = buildApplyStatement tupleStatements
  where
  -- | collects all the props into a tree that can be parsed into scalaz.Apply statements
  tupleStatements :: Array TupleApplyStatement
  tupleStatements = go (Final <$> chunksOf 5 props)
    where
    go statements
      | Array.length statements > 12 = go (Intermediate <$> chunksOf 5 statements)

    go statements = statements

  -- | builds the Apply statements. The recursive funcion `go` returns a record with the two parts of
  -- | the syntax that need to be nested:
  -- | 1. the arguments to scalaz.Apply.tupleN (decoderDefinitionSyntax)
  -- | 2. the syntax to extract the values from the tuples (extractionSyntax)
  buildApplyStatement :: Array TupleApplyStatement -> Codegen Box
  buildApplyStatement statements =
    let
      recursionResults = go <$> statements
    in
      do
        decs <- traverse _.decoderDefinitionSyntax recursionResults
        pure
          $ paren_
              (text ("scalaz.Apply[Decoder.Form[M, *]].apply" <> show (Array.length statements)))
              decs
              (curly (emptyBox 0 0) [ applyAllParams (recursionResults <#> _.extractionSyntax) ])
    where
    go (Final part) =
      if Array.length part == 1 then
        maybe
          ( { decoderDefinitionSyntax: pure (emptyBox 0 0)
            , extractionSyntax: emptyBox 0 0
            }
          )
          ( \r ->
              { decoderDefinitionSyntax:
                  (recordFieldDecoder r <#> (_ <<>> char ','))
              , extractionSyntax:
                  (text r.name) <<>> char ','
              }
          )
          (Array.head part)
      else
        { decoderDefinitionSyntax:
            do
              decs <- traverse (\r -> recordFieldDecoder r <#> (_ <<>> char ',')) part
              pure
                $ paren_
                    (text ("scalaz.Apply[Decoder.Form[M, *]].tuple" <> show (Array.length part)))
                    decs
                    (char ',')
        , extractionSyntax:
            (delimitedLiteral Horiz '(' ')' (part <#> _.name >>> text)) <<>> char ','
        }

    go (Intermediate parts) =
      let
        recursionResults = parts <#> go
      in
        { decoderDefinitionSyntax:
            do
              decs <- traverse (_.decoderDefinitionSyntax) recursionResults
              pure
                $ paren_
                    (text ("scalaz.Apply[Decoder.Form[M, *]].tuple" <> show (Array.length parts)))
                    decs
                    (char ',')
        , extractionSyntax:
            paren_
              (emptyBox 0 0)
              (recursionResults <#> _.extractionSyntax)
              (char ',')
        }

  applyAllParams :: Array Box -> Box
  applyAllParams statements =
    paren_
      (text "case ")
      statements
      (text " =>" // indented applyAllConstructor)
    where
    applyAllConstructor = paren (text name) (props <#> \{ name: n } -> text (n <> " = " <> n <> ","))

chunksOf :: forall a. Int -> Array a -> Array (Array a)
chunksOf n as =
  Array.range 0 ((Array.length as - 1) / n)
    <#> \i ->
        Array.slice (i * n) (i * n + n) as
