module Ccap.Codegen.Purescript
  ( outputSpec
  ) where

import Prelude
import Ccap.Codegen.Annotations (field) as Annotations
import Ccap.Codegen.Annotations (getWrapOpts)
import Ccap.Codegen.Env (Env, askModule, forM)
import Ccap.Codegen.Parser.Export as Export
import Ccap.Codegen.Shared (DelimitedLiteralDir(..), OutputSpec, delimitedLiteral, indented, modulesInScope)
import Ccap.Codegen.Types (Module, Primitive(..), RecordProp, TopType(..), Type(..), TypeDecl(..), ValidatedModule, ModuleName)
import Control.Alt ((<|>))
import Control.Monad.Reader (ReaderT, ask, asks, runReaderT)
import Control.Monad.Writer (class MonadTell, Writer, runWriter, tell)
import Data.Array ((:))
import Data.Array as Array
import Data.Array.NonEmpty as NonEmptyArray
import Data.Foldable (intercalate)
import Data.Function (on)
import Data.Maybe (Maybe(..), fromMaybe, maybe)
import Data.String (Pattern(..))
import Data.String as String
import Data.Traversable (for, traverse)
import Data.Tuple (Tuple(..))
import Node.Path (FilePath)
import Text.PrettyPrint.Boxes (Box, char, hsep, render, text, vcat, vsep, (//), (<<+>>), (<<>>))
import Text.PrettyPrint.Boxes (bottom, left) as Boxes

type PsImport
  = { mod :: String
    , typ :: Maybe String
    , alias :: Maybe String
    }

type Codegen
  = ReaderT Env (Writer (Array PsImport))

runCodegen :: forall a. Env -> Codegen a -> Tuple a (Array PsImport)
runCodegen env c = runWriter (runReaderT c env)

emit :: forall m a. MonadTell (Array PsImport) m => PsImport -> a -> m a
emit imp a = map (const a) (tell [ imp ])

--refactor module names
oneModule :: ValidatedModule -> Box
oneModule mod =
  vsep 1 Boxes.left
    let
      env =
        { defaultPrefix: Nothing
        , currentModule:
            mod
              { imports = mod.imports <#> _.exports.pursPkg
              }
        , allModules: modulesInScope mod
        }

      Tuple body imports = runCodegen env (traverse typeDecl mod.types)

      allImports = imports <> (mod.imports <#> importModule)
    in
      text "-- This file is automatically generated. Do not edit."
        : text ("module " <> mod.exports.pursPkg <> " where")
        : vcat Boxes.left
            ((renderImports <<< mergeImports $ allImports) <#> append "import " >>> text)
        : body

renderImports :: Array PsImport -> Array String
renderImports =
  map \{ mod, typ, alias } ->
    mod
      <> (fromMaybe "" (typ <#> (\t -> " (" <> t <> ")")))
      <> (fromMaybe "" (alias <#> (" as " <> _)))

mergeImports :: Array PsImport -> Array PsImport
mergeImports imps =
  let
    sorted = Array.sortBy ((compare `on` _.mod) <> (compare `on` _.alias)) imps

    grouped = Array.groupBy (\a b -> a.mod == b.mod && a.alias == b.alias) sorted
  in
    grouped
      <#> \group ->
          (NonEmptyArray.head group)
            { typ =
              traverse _.typ group <#> NonEmptyArray.toArray
                >>> Array.sort
                >>> Array.nub
                >>> intercalate ", "
            }

outputSpec :: OutputSpec
outputSpec =
  { render: render <<< oneModule
  , filePath: modulePath
  }

modulePath :: ValidatedModule -> FilePath
modulePath mod = (Export.toPath mod.exports.pursPkg) <> ".purs"

primitive :: Primitive -> Codegen Box
primitive = case _ of
  PBoolean -> pure (text "Boolean")
  PInt -> pure (text "Int")
  PDecimal -> emit { mod: "Data.Decimal", typ: Just "Decimal", alias: Nothing } (text "Decimal")
  PString -> pure (text "String")
  PStringValidationHack -> pure (text "String")
  PJson -> emit { mod: "Data.Argonaut.Core", typ: Nothing, alias: Just "A" } (text "A.Json")

type Extern
  = { prefix :: String, t :: String }

externalType :: Extern -> Codegen Box
externalType { prefix, t } = emit { mod: prefix, typ: Just t, alias: Just prefix } $ text (prefix <> "." <> t)

moduleName :: Module -> String
moduleName { exports: { pursPkg } } = fromMaybe pursPkg $ Array.last $ Export.split pursPkg

importModule :: Module -> PsImport
importModule mod =
  { mod: mod.exports.pursPkg
  , typ: Nothing
  , alias: Just $ moduleName mod
  }

splitType :: String -> Maybe Extern
splitType s = do
  i <- String.lastIndexOf (Pattern ".") s
  let
    prefix = String.take i s
  let
    t = String.drop (i + 1) s
  pure $ { prefix, t }

typeDecl :: TypeDecl -> Codegen Box
typeDecl (TypeDecl name tt annots) =
  let
    dec kw = text kw <<+>> text name <<+>> char '='
  in
    case tt of
      Type t -> do
        ty <- tyType t
        j <- jsonCodec t
        pure $ (dec "type" <<+>> ty)
          // defJsonCodec name j
      Wrap t -> case getWrapOpts "purs" annots of
        Nothing -> do
          other <- otherInstances name
          ty <- tyType t
          j <- newtypeJsonCodec name t
          newtype_ <- newtypeInstances name
          pure
            $ dec "newtype"
            <<+>> text name
            <<+>> ty
            // newtype_
            // other
            // defJsonCodec name j
        Just { typ, decode, encode } -> do
          ty <- externalRef typ
          j <- externalJsonCodec name t decode encode
          pure
            $ dec "type"
            <<+>> ty
            // defJsonCodec name j
      Record props -> do
        recordDecl <- record props <#> \p -> dec "type" // indented p
        codec <- recordJsonCodec props
        pure
          $ recordDecl
          // defJsonCodec name codec
      Sum vs -> do
        other <- otherInstances name
        codec <- sumJsonCodec name vs
        pure
          $ dec "data"
          // indented (hsep 1 Boxes.bottom $ vcat Boxes.left <$> [ Array.drop 1 vs <#> \_ -> char '|', vs <#> text ])
          // other
          // defJsonCodec name codec

sumJsonCodec :: String -> Array String -> Codegen Box
sumJsonCodec name vs = do
  tell
    [ { mod: "Data.Either", typ: Just "Either(..)", alias: Nothing }
    ]
  let
    encode =
      text "encode: case _ of"
        // indented (branches encodeBranch)

    decode =
      text "decode: case _ of"
        // indented (branches decodeBranch // fallthrough)
  emitRuntime $ text "R.composeCodec"
    // indented (delimitedLiteral Vert '{' '}' [ decode, encode ] // text "R.jsonCodec_string")
  where
  branches branch = vcat Boxes.left (vs <#> branch)

  encodeBranch v = text v <<+>> text "->" <<+>> text (show v)

  decodeBranch v = text (show v) <<+>> text "-> Right" <<+>> text v

  fallthrough = text $ "s -> Left $ \"Invalid value \" <> show s <> \" for " <> name <> "\""

newtypeInstances :: String -> Codegen Box
newtypeInstances name = do
  tell
    [ { mod: "Data.Newtype", typ: Just "class Newtype", alias: Nothing }
    , { mod: "Data.Argonaut.Decode", typ: Just "class DecodeJson", alias: Nothing }
    , { mod: "Data.Argonaut.Encode", typ: Just "class EncodeJson", alias: Nothing }
    ]
  pure
    $ text ("derive instance newtype" <> name <> " :: Newtype " <> name <> " _")
    // text ("instance encodeJson" <> name <> " :: EncodeJson " <> name <> " where ")
    // indented (text $ "encodeJson a = jsonCodec_" <> name <> ".encode a")
    // text ("instance decodeJson" <> name <> " :: DecodeJson " <> name <> " where ")
    // indented (text $ "decodeJson a = jsonCodec_" <> name <> ".decode a")

otherInstances :: String -> Codegen Box
otherInstances name = do
  tell
    [ { mod: "Prelude", typ: Nothing, alias: Nothing }
    , { mod: "Data.Generic.Rep", typ: Just "class Generic", alias: Nothing }
    , { mod: "Data.Generic.Rep.Show", typ: Just "genericShow", alias: Nothing }
    ]
  pure
    $ text ("derive instance eq" <> name <> " :: Eq " <> name)
    // text ("derive instance ord" <> name <> " :: Ord " <> name)
    // text ("derive instance generic" <> name <> " :: Generic " <> name <> " _")
    // text ("instance show" <> name <> " :: Show " <> name <> " where")
    // indented (text "show a = genericShow a")

tyType :: Type -> Codegen Box
tyType =
  let
    wrap tycon t = tyType t <#> \ty -> text tycon <<+>> parens ty
  in
    case _ of
      Primitive p -> primitive p
      Ref _ { mod, typ } -> internalRef mod typ
      Array t -> wrap "Array" t
      Option t -> tell (pure { mod: "Data.Maybe", typ: Just "Maybe", alias: Nothing }) >>= const (wrap "Maybe" t)

internalRef :: Maybe ModuleName -> String -> Codegen Box
internalRef modName typ = do
  allMods <- asks _.allModules
  mod <- forM modName askModule
  path <- for mod \m -> modulePrefix m <#> flip moduleRef m
  pure $ text $ maybe typ (flip qualify typ) path

qualify :: Array String -> String -> String
qualify path = intercalate "." <<< Array.snoc path

packageAnnotation :: Module -> Maybe String
packageAnnotation = Annotations.field "purs" "modulePrefix" <<< _.annots

modulePrefix :: Module -> Codegen (Maybe String)
modulePrefix mod = do
  { defaultPrefix } <- ask
  pure $ packageAnnotation mod <|> defaultPrefix

moduleRef :: Maybe String -> Module -> Array String
moduleRef prefix mod = Array.fromFoldable prefix `Array.snoc` (moduleName mod)

externalRef :: String -> Codegen Box
externalRef s = fromMaybe (text s # pure) (splitType s <#> externalType)

emitRuntime :: Box -> Codegen Box
emitRuntime b = emit { mod: "Ccap.Codegen.Runtime", typ: Nothing, alias: Just "R" } b

newtypeJsonCodec :: String -> Type -> Codegen Box
newtypeJsonCodec name t = do
  i <- jsonCodec t
  emitRuntime $ text "R.codec_newtype" <<+>> parens i

externalJsonCodec :: String -> Type -> String -> String -> Codegen Box
externalJsonCodec name t decode encode = do
  i <- jsonCodec t
  decode_ <- externalRef decode
  encode_ <- externalRef encode
  emitRuntime $ text "R.codec_custom" <<+>> decode_ <<+>> encode_ <<+>> parens i

codecName :: Maybe String -> String -> String
codecName mod t = qualify (Array.fromFoldable mod) $ "jsonCodec_" <> t

jsonCodec :: Type -> Codegen Box
jsonCodec ty = case ty of
  Primitive p ->
    pure
      ( text
          $ codecName (Just "R")
              ( case p of
                  PBoolean -> "boolean"
                  PInt -> "int"
                  PDecimal -> "decimal"
                  PString -> "string"
                  PStringValidationHack -> "string"
                  PJson -> "json"
              )
      )
  Array t -> tycon "array" t
  Option t -> tycon "maybe" t
  Ref _ { mod, typ } -> internalRef mod ("jsonCodec_" <> typ)
  where
  tycon which t = do
    ref <- jsonCodec t
    pure $ text ("(" <> codecName (Just "R") which <> " ") <<>> ref <<>> text ")"

parens :: Box -> Box
parens b = char '(' <<>> b <<>> char ')'

defJsonCodec :: String -> Box -> Box
defJsonCodec name def =
  let
    cname = codecName Nothing name
  in
    text cname <<+>> text ":: R.JsonCodec" <<+>> text name
      // (text cname <<+>> char '=')
      // indented def

record :: Array RecordProp -> Codegen Box
record props = do
  tell [ { mod: "Data.Tuple", typ: Just "Tuple(..)", alias: Nothing } ]
  types <- for props $ _.typ >>> tyType
  let
    labels = props <#> \{ name } -> text name <<+>> text "::"
  pure $ delimitedLiteral Vert '{' '}' (Array.zip labels types <#> \(Tuple l t) -> l <<+>> t)

recordJsonCodec :: Array RecordProp -> Codegen Box
recordJsonCodec props = do
  tell
    [ { mod: "Data.Argonaut.Core", typ: Nothing, alias: Just "A" }
    , { mod: "Ccap.Codegen.Runtime", typ: Nothing, alias: Just "R" }
    , { mod: "Foreign.Object", typ: Nothing, alias: Just "FO" }
    , { mod: "Prelude", typ: Nothing, alias: Nothing }
    ]
  encodeProps <- recordWriteProps props
  decodeProps <- recordReadProps props
  let
    encode =
      text "encode: \\p -> A.fromObject $"
        // indented
            ( text "FO.fromFoldable"
                // indented encodeProps
            )

    names = props <#> _.name >>> text

    decode =
      text "decode: \\j -> do"
        // indented
            ( text "o <- R.obj j"
                // decodeProps
                // (text "pure" <<+>> delimitedLiteral Horiz '{' '}' names)
            )
  pure $ delimitedLiteral Vert '{' '}' [ decode, encode ]

recordWriteProps :: Array RecordProp -> Codegen Box
recordWriteProps props = do
  types <-
    for props \{ name, typ } -> do
      x <- jsonCodec typ
      pure $ text "Tuple" <<+>> text (show name) <<+>> parens (x <<>> text ".encode p." <<>> text name)
  pure $ delimitedLiteral Vert '[' ']' types

recordReadProps :: Array RecordProp -> Codegen Box
recordReadProps props = do
  lines <-
    for props \{ name, typ } -> do
      x <- jsonCodec typ
      pure $ text name <<+>> text "<- R.decodeProperty" <<+>> text (show name) <<+>> x <<+>> text "o"
  pure $ vcat Boxes.left lines
