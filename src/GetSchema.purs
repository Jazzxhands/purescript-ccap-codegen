module GetSchema
  ( main
  ) where

import Prelude
import Ccap.Codegen.Cst as Cst
import Ccap.Codegen.Database as Database
import Ccap.Codegen.PrettyPrint as PrettyPrint
import Ccap.Codegen.Util (liftEffectSafely, processResult, scrubEolSpaces)
import Control.Monad.Except (ExceptT, except)
import Data.Either (Either(..), note)
import Data.Foldable (traverse_)
import Data.Int (fromString) as Int
import Data.Maybe (Maybe(..))
import Data.String as String
import Data.Traversable (for)
import Database.PostgreSQL.PG (PoolConfiguration, defaultPoolConfiguration, newPool)
import Effect (Effect)
import Effect.Aff (Aff, launchAff_)
import Effect.Class (liftEffect)
import Effect.Class.Console as Console
import Node.Yargs.Applicative (flag, runY, yarg)
import Node.Yargs.Setup (usage)

app :: Boolean -> String -> String -> String -> String -> Effect Unit
app domains dbConfig tableParam scalaPkg pursPkg =
  launchAff_
    $ processResult do
        let
          checkString s =
            if String.length s > 0 then
              Just s
            else
              Nothing

          table = checkString tableParam
        poolConfig <- except (readPoolConfig dbConfig)
        let
          config = { domains, table, poolConfig, scalaPkg, pursPkg }
        fromDb <- dbModules config
        traverse_ writeModule fromDb
  where
  readPoolConfig :: String -> Either String PoolConfiguration
  readPoolConfig s = fromParts parts
    where
    parts = String.split (String.Pattern ":") s

    poolConfig db = (defaultPoolConfiguration db) { idleTimeoutMillis = Just 500 }

    fromParts [ host, port, db, user ] =
      portFromString port
        <#> \p ->
            (poolConfig db)
              { host = Just host
              , port = Just p
              , user = Just user
              }

    fromParts [ host, port, db, user, password ] =
      portFromString port
        <#> \p ->
            (poolConfig db)
              { host = Just host
              , port = Just p
              , user = Just user
              , password = Just password
              }

    fromParts _ = Left "Config parameter must be of the form <host>:<port>:<db>:<user>:<password> (password optional)"

    portFromString = note "Database port must be an integer" <<< Int.fromString

dbModules :: Config -> ExceptT String Aff (Maybe Cst.Module)
dbModules config = do
  pool <- liftEffect $ newPool config.poolConfig
  if config.domains then
    Just <$> Database.domainModule pool config.scalaPkg config.pursPkg
  else
    for config.table $ Database.tableModule pool config.scalaPkg config.pursPkg

type Config
  = { domains :: Boolean
    , table :: Maybe String
    , poolConfig :: PoolConfiguration
    , scalaPkg :: String
    , pursPkg :: String
    }

prependNotice :: String -> String
prependNotice = ("// This file is automatically generated from DB schema. Do not edit.\n" <> _)

writeModule :: Cst.Module -> ExceptT String Aff Unit
writeModule = liftEffectSafely <<< print
  where
  print = Console.info <<< prependNotice <<< scrubEolSpaces <<< PrettyPrint.prettyPrint

main :: Effect Unit
main = do
  let
    setup = usage "$0 --config <host>:<port>:<db>:<user> [ --domains | --table <table> ]"
  runY setup $ app
    <$> flag
        "d"
        [ "domains" ]
        (Just "Query database domains")
    <*> yarg
        "c"
        [ "config" ]
        (Just "The database to use")
        (Right "Config is required")
        true
    <*> yarg
        "t"
        [ "table" ]
        (Just "Query the provided database table")
        (Left "")
        true
    <*> yarg
        "ts"
        [ "scala-pkg" ]
        (Just "scala package name for table")
        (Right "flag 'scala-pkg' is required")
        true
    <*> yarg
        "tp"
        [ "purs-pkg" ]
        (Just "purescript package name for table")
        (Right "flag 'purs-pkg' is required")
        true
