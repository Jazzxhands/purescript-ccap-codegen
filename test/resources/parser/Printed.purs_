-- This file is automatically generated. Do not edit.

module Test.Printed where

import Ccap.Codegen.Runtime as R
import Data.Argonaut.Core as A
import Data.Argonaut.Decode (class DecodeJson)
import Data.Argonaut.Encode (class EncodeJson)
import Data.Decimal (Decimal)
import Data.Generic.Rep (class Generic)
import Data.Generic.Rep.Show (genericShow)
import Data.Maybe (Maybe)
import Data.Newtype (class Newtype)
import Data.Tuple (Tuple(..))
import Foreign.Object as FO
import Prelude
import Test.Imported as Imported

type YesNo = Boolean
jsonCodec_YesNo :: R.JsonCodec YesNo
jsonCodec_YesNo =
  R.jsonCodec_boolean

type Number = Decimal
jsonCodec_Number :: R.JsonCodec Number
jsonCodec_Number =
  R.jsonCodec_decimal

type Text = String
jsonCodec_Text :: R.JsonCodec Text
jsonCodec_Text =
  R.jsonCodec_string

type Integer = Int
jsonCodec_Integer :: R.JsonCodec Integer
jsonCodec_Integer =
  R.jsonCodec_int

newtype TagType = TagType Int
derive instance newtypeTagType :: Newtype TagType _
instance encodeJsonTagType :: EncodeJson TagType where
  encodeJson a = jsonCodec_TagType.encode a
instance decodeJsonTagType :: DecodeJson TagType where
  decodeJson a = jsonCodec_TagType.decode a
derive instance eqTagType :: Eq TagType
derive instance ordTagType :: Ord TagType
derive instance genericTagType :: Generic TagType _
instance showTagType :: Show TagType where
  show a = genericShow a
jsonCodec_TagType :: R.JsonCodec TagType
jsonCodec_TagType =
  R.codec_newtype (R.jsonCodec_int)

type Optional = Maybe (Int)
jsonCodec_Optional :: R.JsonCodec Optional
jsonCodec_Optional =
  (R.jsonCodec_maybe R.jsonCodec_int)

type Collection = Array (Int)
jsonCodec_Collection :: R.JsonCodec Collection
jsonCodec_Collection =
  (R.jsonCodec_array R.jsonCodec_int)

type Point =
  { x :: Int
  , y :: Int
  }
jsonCodec_Point :: R.JsonCodec Point
jsonCodec_Point =
  { decode: \j -> do
      o <- R.obj j
      x <- R.decodeProperty "x" R.jsonCodec_int o
      y <- R.decodeProperty "y" R.jsonCodec_int o
      pure { x, y }
  , encode: \p -> A.fromObject $
      FO.fromFoldable
        [ Tuple "x" (R.jsonCodec_int.encode p.x)
        , Tuple "y" (R.jsonCodec_int.encode p.y)
        ]
  }

type InternalRef = Integer
jsonCodec_InternalRef :: R.JsonCodec InternalRef
jsonCodec_InternalRef =
  jsonCodec_Integer

type ExternalRef = Imported.ImportedType
jsonCodec_ExternalRef :: R.JsonCodec ExternalRef
jsonCodec_ExternalRef =
  Imported.jsonCodec_ImportedType

type Validated = String
jsonCodec_Validated :: R.JsonCodec Validated
jsonCodec_Validated =
  R.jsonCodec_string

type ValidatedMaybe = Maybe (String)
jsonCodec_ValidatedMaybe :: R.JsonCodec ValidatedMaybe
jsonCodec_ValidatedMaybe =
  (R.jsonCodec_maybe R.jsonCodec_string)

type ValidatedRec =
  { name :: String
  }
jsonCodec_ValidatedRec :: R.JsonCodec ValidatedRec
jsonCodec_ValidatedRec =
  { decode: \j -> do
      o <- R.obj j
      name <- R.decodeProperty "name" R.jsonCodec_string o
      pure { name }
  , encode: \p -> A.fromObject $
      FO.fromFoldable
        [ Tuple "name" (R.jsonCodec_string.encode p.name)
        ]
  }
