// This file is automatically generated. Do not edit.

package test

import gov.wicourts.jsoncommon.Decoder
import gov.wicourts.jsoncommon.Encoder
import scalaz.Monad

object Printed {

  type YesNo = Boolean
  lazy val jsonEncoderYesNo: Encoder[YesNo, argonaut.Json] =
    Encoder.boolean
  def jsonDecoderYesNo[M[_]: Monad]: Decoder.Field[M, YesNo] =
    Decoder.boolean

  type Number = BigDecimal
  lazy val jsonEncoderNumber: Encoder[Number, argonaut.Json] =
    Encoder.decimal
  def jsonDecoderNumber[M[_]: Monad]: Decoder.Field[M, Number] =
    Decoder.decimal

  type Text = String
  lazy val jsonEncoderText: Encoder[Text, argonaut.Json] =
    Encoder.string
  def jsonDecoderText[M[_]: Monad]: Decoder.Field[M, Text] =
    Decoder.string

  type Integer = Int
  lazy val jsonEncoderInteger: Encoder[Integer, argonaut.Json] =
    Encoder.int
  def jsonDecoderInteger[M[_]: Monad]: Decoder.Field[M, Integer] =
    Decoder.int

  final abstract class TagTypeT
  type TagType = scalaz.@@[Int, TagTypeT]
  val TagType: scalaz.Tag.TagOf[TagTypeT] = scalaz.Tag.of[TagTypeT]
  lazy val jsonEncoderTagType: Encoder[TagType, argonaut.Json] =
    Encoder.int.tagged
  def jsonDecoderTagType[M[_]: Monad]: Decoder.Field[M, TagType] =
    Decoder.int.tagged

  type Optional = Option[Int]
  lazy val jsonEncoderOptional: Encoder[Optional, argonaut.Json] =
    Encoder.int.option
  def jsonDecoderOptional[M[_]: Monad]: Decoder.Field[M, Optional] =
    Decoder.int.option

  type Collection = List[Int]
  lazy val jsonEncoderCollection: Encoder[Collection, argonaut.Json] =
    Encoder.int.list
  def jsonDecoderCollection[M[_]: Monad]: Decoder.Field[M, Collection] =
    Decoder.int.list

  final case class Point(
    x: Int,
    y: Int,
  )
  lazy val jsonEncoderPoint: Encoder[Point, argonaut.Json] =
    x => argonaut.Json.obj(
      "x" -> Encoder.int.encode(x.x),
      "y" -> Encoder.int.encode(x.y),
    )
  def jsonDecoderPoint[M[_]: Monad]: Decoder.Form[M, Point] =
    scalaz.Apply[Decoder.Form[M, *]].apply2(
      Decoder.int.property("x"),
      Decoder.int.property("y"),
    )(Point.apply)
  object Point {
    object FieldNames {
      val X: String = "x"
      val Y: String = "y"
    }
  }

  type InternalRef = Integer
  lazy val jsonEncoderInternalRef: Encoder[InternalRef, argonaut.Json] =
    jsonEncoderInteger
  def jsonDecoderInternalRef[M[_]: Monad]: Decoder.Field[M, InternalRef] =
    jsonDecoderInteger

  type ExternalRef = Imported.ImportedType
  lazy val jsonEncoderExternalRef: Encoder[ExternalRef, argonaut.Json] =
    Imported.jsonEncoderImportedType
  def jsonDecoderExternalRef[M[_]: Monad]: Decoder.Field[M, ExternalRef] =
    Imported.jsonDecoderImportedType

  type Validated = String
  lazy val jsonEncoderValidated: Encoder[Validated, argonaut.Json] =
    Encoder.string
  def jsonDecoderValidated[M[_]: Monad]: Decoder.Field[M, Validated] =
    Decoder.string.maxLength(5)

  type ValidatedMaybe = Option[String]
  lazy val jsonEncoderValidatedMaybe: Encoder[ValidatedMaybe, argonaut.Json] =
    Encoder.string.option
  def jsonDecoderValidatedMaybe[M[_]: Monad]: Decoder.Field[M, ValidatedMaybe] =
    Decoder.string.maxLength(5).option

  final case class ValidatedRec(
    name: String,
  )
  lazy val jsonEncoderValidatedRec: Encoder[ValidatedRec, argonaut.Json] =
    x => argonaut.Json.obj(
      "name" -> Encoder.string.encode(x.name),
    )
  def jsonDecoderValidatedRec[M[_]: Monad]: Decoder.Form[M, ValidatedRec] =
    Decoder.string.maxLength(5).property("name").map(ValidatedRec.apply)
  object ValidatedRec {
    object FieldNames {
      val Name: String = "name"
    }
  }

}
